// 
//  This is part of Geant4 simulation code developed at UChicago, for simulating 
//  neutron background at SNS, and energy in CosI detector and scintillation detector.   
//  Author : Gopan Perumpilly , gopan.p@gmail.com
// 



#include "SNSParallelTargetDetector.hh"
#include "SNSParallelMessenger.hh"

#include "globals.hh"  
#include <sstream>
#include <map>
#include "G4ios.hh"
#include "G4LogicalVolume.hh"
#include "G4VPhysicalVolume.hh"
#include "G4LogicalVolumeStore.hh"
#include "G4Box.hh"
#include "G4Tubs.hh"
#include "G4Sphere.hh"
#include "G4SubtractionSolid.hh"
#include "G4UnionSolid.hh"
#include "G4Material.hh"
#include "G4VisAttributes.hh"
#include "G4Color.hh"
#include "G4ThreeVector.hh"
#include "G4SystemOfUnits.hh"
#include "G4PhysicalConstants.hh"
#include "G4UserLimits.hh"
#include "G4SDManager.hh"
#include "G4RunManager.hh"
#include "G4PVPlacement.hh"



// For Primitive Scorers
#include "G4SDManager.hh"
#include "G4MultiFunctionalDetector.hh"
#include "G4SDParticleFilter.hh"
#include "G4PSNofCollision.hh"
#include "G4PSPopulation.hh"
#include "G4PSTrackCounter.hh"
#include "G4PSTrackLength.hh"
#include "G4VIStore.hh"
#include "G4IStore.hh"   // for importance biasing
#include "G4WeightWindowStore.hh"    // for weight window technique


SNSParallelTargetDetector::SNSParallelTargetDetector(G4String worldName)
:G4VUserParallelWorld(worldName),
 fParallelWorld(NULL), 
 fIsVariableStep(false), fNumVol(10), fLogicalVolumeVector()
{
    fMessenger = new SNSParallelMessenger(this);
}

SNSParallelTargetDetector::~SNSParallelTargetDetector()
{
	delete fMessenger;
}

void SNSParallelTargetDetector::Construct()
{


	fParallelWorld = GetWorld();
	G4cout << "Constructing Parallel World" << G4endl;
    
    //G4Material* dummyMat  = 0;

    G4cout << " SNSParallelTargetDetector:: ParallelWorldName = " 
                 << fParallelWorld->GetName() << G4endl;
                 
	G4LogicalVolume* parallelWorldLogical = fParallelWorld->GetLogicalVolume();

	
	//Don't change the following keyword in comment, used in script
	fNumVol 					= 70; //NUMVOL
	
	G4double detHalfHt = 0.5*m;
	G4bool surfaceDet = false;
detHalfHt = 1.*m;
surfaceDet = true;
	//use exampleRE06.cc to set meesenger
    G4bool cylSection          = false;
	G4double parCylHalfHt 		= 7.*m; //	
if(surfaceDet)parCylHalfHt = 3.5*m;// 7/2 
	G4double mainVolRad		    = 22.3*m;	
	if(surfaceDet) mainVolRad  = 10.*m; //25 - detToWallHor
    G4double offBeamZ 			= 0.5*m;	  //protBoxHalfXZ= 2*m;
if(surfaceDet) offBeamZ    = -2.*m ;//detToTargetFullZ 
	G4double offTargetAxis		= 1.*m;
	G4double detToWallHor		= 1.5*m;
if(surfaceDet)detToWallHor		= 0.3*m;
	G4double detToWallVert		= detHalfHt + 0.5*m;
if(surfaceDet)detToWallVert		= 0.1*m + detHalfHt;
	G4double detToTargetRad   	= mainVolRad + detToWallHor;	

	G4double stepCylRad 		= (mainVolRad - offTargetAxis)/fNumVol-1;
	G4double stepCylHt  		= (parCylHalfHt - detToWallVert)/fNumVol-1; 	
	G4double posParCylZ        =  -parCylHalfHt -offBeamZ;
	if(surfaceDet) posParCylZ  =  offBeamZ;
	G4ThreeVector posParCyl(0,0, posParCylZ); //cylinder  
	G4ThreeVector posParBox(18.2*m,-5.*m,-parCylHalfHt -offBeamZ);
	
	G4ThreeVector center(0,0,0);
	G4PVPlacement* parallelPhys = NULL;
	G4LogicalVolume* parLog 	= NULL;	
	G4RotationMatrix* rot 	    = new G4RotationMatrix(); 

	G4double dA = 15.*degree/fNumVol; 
	G4double theta1 = 0, theta2 = 0, theta3 = 0, theta4 = 0;	
	
	G4String shape = "cylinder";//"box" 
	
	theta1 = theta3 = 0;
	theta2 = theta4 = twopi;
	
	for(G4int i=0; i<fNumVol+1; i++) 
    {
        std::ostringstream ss;
		ss << "parallelSNS"<< i;
        G4String pName = ss.str();
		
		if(shape == "cylinder") //cylinder
		{
            G4SubtractionSolid* cylSolid = NULL;

            G4Tubs* cylFull = NULL;
			G4Tubs* cylInner = NULL;
			
			if(cylSection)
			{
				theta1 = 3./2.*pi+ i*dA;
				theta2 = pi/2.-2.*i*dA;
				theta3 = 3./2.*pi+ (i+1)*dA;
				theta4 = pi/2.-2.*(i+1)*dA;
			}
            G4cout << " Full:  rad1 " << (i*stepCylRad+offTargetAxis)/m 
					<<  " rad2 "<<(2.*detToTargetRad-offTargetAxis-i*stepCylRad)/m  
					<< " ht "<<(parCylHalfHt-i*stepCylHt)/m  << G4endl;
            
            
            cylFull = new G4Tubs("BasementCyl", i*stepCylRad+ offTargetAxis, 
                    2.*detToTargetRad- offTargetAxis-i*stepCylRad, 
                    parCylHalfHt-i*stepCylHt, theta1, theta2 ); // 0, twopi);
            if(i < fNumVol)
            {		
                cylInner = new G4Tubs("CylIn",(i+1)*stepCylRad+offTargetAxis,
                    2.*detToTargetRad- offTargetAxis-(i+1)*stepCylRad, 
                    parCylHalfHt-(i+1)*stepCylHt, theta3, theta4); //0,twopi
                
                G4cout << " Inner:  rad1 " << ((i+1)*stepCylRad+offTargetAxis)/m 
						<<  " rad2 "<<(2.*detToTargetRad-offTargetAxis-(i+1)*stepCylRad)/m  
						<< " ht "<<(parCylHalfHt-(i+1)*stepCylHt)/m << G4endl;
            
                cylSolid =  new G4SubtractionSolid("SubCyl",cylFull, cylInner, rot, center);	
                parLog = new G4LogicalVolume(cylSolid,0,pName+"Log");
            }
            else if(i == fNumVol)
            {
                parLog = new G4LogicalVolume(cylFull,0,pName+"Log");
            }

			parLog->SetVisAttributes(new G4VisAttributes(G4Colour::Cyan()));
			parallelPhys = new G4PVPlacement(rot, posParCyl, parLog,// NOTE change pos
											 pName, parallelWorldLogical, false, 0);
		
		}/*
		else if (shape == "box")
		{
			G4SubtractionSolid* boxSub = NULL;
			G4Box* boxFull = NULL;
			B4Box* boxIn   = NULL;
			G4cout << " Full:  rad1 " << (i*stepCylRad+offTargetAxis)/m 
			<<  " rad2 "<<(2.*detToTargetRad-offTargetAxis-i*stepCylRad)/m  
			<< " ht "<<(parCylHalfHt-i*stepCylHt)/m << G4endl;
			
			
			boxFull = new G4Tubs("BasementCyl", i*stepCylRad+ offTargetAxis, 
								 2.*detToTargetRad- offTargetAxis-i*stepCylRad, 
						parCylHalfHt-i*stepCylHt, 0, twopi);
			if(i < fNumVol)
			{		
				cylInner = new G4Tubs("CylIn",(i+1)*stepCylRad+offTargetAxis,
				2.*detToTargetRad- offTargetAxis-(i+1)*stepCylRad, 
				parCylHalfHt-(i+1)*stepCylHt, 0, twopi);
				
				G4cout << " Inner:  rad1 " << ((i+1)*stepCylRad+offTargetAxis)/m 
				<<  " rad2 "<<(2.*detToTargetRad-offTargetAxis-(i+1)*stepCylRad)/m  
				<< " ht "<<(parCylHalfHt-(i+1)*stepCylHt)/m << G4endl;
				
				cylSolid =  new G4SubtractionSolid("SubCyl",cylFull, cylInner, rot, center);
				parLog = new G4LogicalVolume(cylSolid,0,pName+"Log");
			}
			else if(i == fNumVol)
			{
				parLog = new G4LogicalVolume(cylFull,0,pName+"Log");
			}
			parLog->SetVisAttributes(new G4VisAttributes(G4Colour::Red()));
			parallelPhys = new G4PVPlacement(rot, posParBox, parLog, 
										pName, parallelWorldLogical, false, 0);
		}*/

        SetImportanceValueForRegion(parallelPhys, std::pow(2.0, i+1.0) );//NOTE
        //fPhysicalVolumeVector.push_back(HgBox->GetPartLog());
        //parallelWorldLogical = parLog; // to nest the next volume in this
    }
}	


    /*
    //G4double deltaFraction         = 0.2; //for variable step 
    //fNumVol/2*(2*stepCylRadVar+ (fNumVol-1)*delta) = detToTargetRad-detToWallHor;
    //stepCylRadVar+ 0.5*(fNumVol-1)*(deltaFraction*stepCylRadVar) = (detToTargetRad-detToWallHor)/fNumVol;
    //stepCylRadVar(1+ 0.5*(fNumVol-1)*deltaFraction) = (detToTargetRad-detToWallHor)/fNumVol;  
    //G4double stepCylRadVar      = (detToTargetRad - detToWallHor)/fNumVol*1/(1+ 0.5*(fNumVol-1)*deltaFraction);
    if(fIsVariableStep)
    {
        if(i == fNumVol-1)
        {
            cylFull  = new G4Tubs("BasementCyl", fNumVol*stepCylRadVar*(1+ deltaFraction), 
                        fNumVol*stepCylRadVar*(1+ deltaFraction)+2.*detToWallHor, 
                        parCylHalfHt-i*stepCylHt, 0, twopi);
            G4cout << "last:rad1 " <<   fNumVol*stepCylRadVar*(1+ deltaFraction)/m << " rad2 "<< 
            (fNumVol*stepCylRadVar*(1+ deltaFraction)+2.*detToWallHor)/m << " ht "<< 
            (parCylHalfHt-i*stepCylHt)/m << G4endl;
        }
        else
        {
            cylFull = new G4Tubs("BasementCyl",  i*stepCylRadVar*(1+ deltaFraction), 
                        2.*detToTargetRad-i*stepCylRadVar*(1 +deltaFraction),
                        parCylHalfHt-i*stepCylHt, 0, twopi);//cylinder                    
        }
        cylInner = new G4Tubs("CylIn",(i+1)*stepCylRadVar*(1+ deltaFraction),
                        2.*detToTargetRad-(i+1)*stepCylRadVar*(1+ deltaFraction), 
                        parCylHalfHt-(i+1)*stepCylHt, 0, twopi);
        cylSolid =  new G4SubtractionSolid("SubCyl",cylFull, cylInner, rot, center);
        parLog = new G4LogicalVolume(cylSolid,0,pName+"Log");
    }//if variable step
    */


//void SNSParallelTargetDetector::ConstructSD()
//{}                        

//G4VIStore*
void SNSParallelTargetDetector::CreateImportanceStore()
{
	G4cout << "SNSParallelTargetDetector:: Creating Importance Store "<< G4endl;

	G4IStore *istore = G4IStore::GetInstance(GetName());
	
	G4GeometryCell parallelVolCell(GetConstWorldVolumeAddress(), 0);
	istore->AddImportanceGeometryCell(1, parallelVolCell);
	
   for(std::map<G4VPhysicalVolume*, std::pair<G4double, G4int>* >::iterator i =
      fImportanceMap.begin();i != fImportanceMap.end(); i++)
   {
      istore->AddImportanceGeometryCell((i->second)->first,
         *(i->first), (i->second)->second);

      G4cout <<" Volume added: "<< (i->first)->GetName() << " (Replica "
     <<(i->second)->second<< ") of imp value: "<< (i->second)->first <<G4endl;
   }
   // return istore;
}

//---------------------------------------------------------------------------//

void SNSParallelTargetDetector::SetImportanceValueForRegion(
  G4VPhysicalVolume* aVol,  G4double anImpValue,   G4int aRepNum)
{
   // sets importance value (default kMinImpValue)
   // anImpValue: 0 -> particle will be killed
   //           : > 0 -> allowed (higher means greater importance)
   //           : < 0 -> not allowed!

  if (anImpValue< 0) G4cout << "Error in importance value..."<< G4endl;
  else
  {
    std::map<G4VPhysicalVolume*, std::pair<G4double, G4int>* > :: const_iterator anIt;
    anIt = fImportanceMap.find(aVol);
    if(anIt == fImportanceMap.end())
    {
      if(anImpValue < kMinImpValue && anImpValue > 0.) anImpValue = kMinImpValue;
      std::pair<G4double, G4int>* aPair =
        new std::pair<G4double, G4int>(anImpValue, aRepNum);
      fImportanceMap.insert(
        std::pair<G4VPhysicalVolume*, std::pair<G4double, G4int>* >(aVol,aPair));
      G4cout << "Set " << aVol->GetName() << " (: " << aRepNum
        << ") of importance: " << anImpValue << G4endl;
    }
    else
    {
      G4cout << "WARNING: Importance numberfor: " << aVol->GetName()
        << " had been set" << G4endl;
    }
  }
}

//---------------------------------------------------------------------

void SNSParallelTargetDetector::SetNumVolumes( G4int numVol)
{ 
	fNumVol = numVol;
	//G4RunManager::GetRunManager()->ReinitializeGeometry();
}
//-------------------------------------------------------------------
void SNSParallelTargetDetector::SetIsVariableStep ( G4bool val)
{ 
	fIsVariableStep = val;
	//G4RunManager::GetRunManager()->ReinitializeGeometry();
}


